# 模拟时间片轮转调度算法

## 题目介绍

本题目旨在模拟操作系统中的时间片轮转（Round Robin, RR）调度算法。时间片轮转是一种公平的进程调度策略，它通过为每个进程分配固定长度的时间片来实现CPU时间的分配。

本题可参考[第七章 操作系统常用算法](../chapter_4.md)中的[模拟时间片轮转调度算法](../chapter_4_3.md)

### 题目要求

- 补充实现 `calculateTimes` 函数，根据时间片轮转算法计算每个进程的完成时间、周转时间和等待时间。

### 输入

- 程序中硬编码了所有数据，包括时间片长度、进程数量、每个进程的到达时间和运行时间。

### 输出

- 计算并输出每个进程的完成时间、周转时间和等待时间。

### 示例

- 给出的进程列表和时间片长度下，输出类似如下结果：
  ```
  P1: 完成时间: 28, 周转时间: 28, 等待时间: 18
  P2: 完成时间: 22, 周转时间: 21, 等待时间: 15
  P3: 完成时间: 26, 周转时间: 24, 等待时间: 16
  P4: 完成时间: 16, 周转时间: 13, 等待时间: 9
  ```

## 代码介绍

### main.c

主函数文件，包含了进程数组的定义和调用 `calculateTimes` 函数的逻辑。

```c
int main() {
    // ...
    calculateTimes(processes, n, time_slice);
    for (int i = 0; i < n; i++) {
        printf("P%d:%d,%d,%d\n", processes[i].pid, processes[i].completion_time,
               processes[i].turnaround_time, processes[i].waiting_time);
    }
    return EXIT_SUCCESS;
}
```

### RR.c

包含 `calculateTimes` 函数的实现，该函数需要根据时间片轮转算法填充进程结构体中的相关字段。

```c
void calculateTimes(Process *processes, int n, int time_slice) {
    // TODO
}
```

### RR.h

头文件，定义了进程结构体 `Process` 和 `calculateTimes` 函数的声明。

```c
typedef struct {
    // ...
} Process;

void calculateTimes(Process *processes, int n, int time_slice);
```

## 详细提示信息

### 时间片轮转算法逻辑

- 维护一个就绪队列来存储所有等待执行的进程。
- 将CPU时间分配给队首进程，长度为时间片。
- 如果进程在时间片内完成，则将其移出队列。
- 如果进程未完成，则将其移动到队列末尾，并继续处理下一个进程。

### 计算指标

- **完成时间**：进程实际完成执行的时间点。
- **周转时间**：从进程到达到完成的总时间（完成时间 - 到达时间）。
- **等待时间**：进程在就绪队列中等待的时间（周转时间 - 运行时间）。

### 注意事项

- 确保正确处理进程的到达时间和运行时间。
- 考虑进程可能在一个时间片内完成或需要多个时间片完成。
- 维护一个当前时间变量，以跟踪模拟的进度。
- 参与者需要根据题目要求，完成 `calculateTimes` 函数的实现，确保能够正确模拟时间片轮转调度算法，并计算出每个进程的相关指标。通过这个练习，可以加深对操作系统进程调度机制的理解。
