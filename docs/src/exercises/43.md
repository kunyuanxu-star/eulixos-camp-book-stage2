# 使用内联 RISCV 汇编实现计算斐波那契数列的第 n 个数

## 题目介绍

本题目要求参与者使用RISC-V汇编语言内联在C程序中，实现计算斐波那契数列第n项的函数。斐波那契数列是一个每一项都是前两项和的序列，通常定义为F(0) = 0, F(1) = 1, 且对于n > 1, 有 F(n) = F(n-1) + F(n-2)。

本题可参考[第六章 RISC-V架构内联汇编](../chapter_3.md)全部小节内容。

## 题目要求

- 使用RISC-V汇编语言内联在C函数中。
- 实现计算斐波那契数列第n项的值。
- 编写的汇编代码需要替换C函数中的PLACEHOLDER。

## 输入

- 命令行参数，一个整数n，表示斐波那契数列的位置。

## 输出

- 斐波那契数列第n项的值。

## 示例

- 如果输入是 `5`，则输出应该是 `5`，因为斐波那契数列的第5项是5。

## 代码介绍

1. **main.c** 文件包含了主函数和 `fibonacci` 函数的C包装器。
   - `main` 函数处理命令行参数，并调用 `fibonacci` 函数打印结果。
   - `fibonacci` 函数使用内联汇编实现，其中包含了多个PLACEHOLDER，需要用正确的RISC-V汇编指令替换。

2. 内联汇编使用GCC的扩展语法，其中：
   - `"li"` 指令用于将立即数加载到寄存器。
   - `"addi"` 指令用于将一个立即数加到寄存器。
   - `"add"` 指令用于将两个寄存器的值相加。
   - `"mv"` 指令用于将一个寄存器的值移动到另一个寄存器。
   - `"bne"` 指令用于比较两个寄存器，如果不相等则跳转到指定标签。
   - `"j"` 指令用于无条件跳转。

## 详细提示信息

- **内联汇编替换**：
  - 使用RISC-V汇编指令替换PLACEHOLDER，完成斐波那契数列的计算。
  - 对于 `n == 0`，应返回0，使用 `"li %0, 0"` 并跳转至结束标签。
  - 对于 `n == 1`，应返回1，使用 `"li %0, 1"` 并跳转至结束标签。
  - 在循环中，使用 `"add"` 更新斐波那契数列的值，并使用 `"mv"` 或 `"addi"` 更新寄存器。

- **控制流**：
  - 使用 `"bne"` 指令控制循环，直到 `n` 减至0。

- **寄存器使用**：
  - `%0` 用于存储结果。
  - `%1` 用于存储参数n，并在循环中递减。
  - `t0`, `t1`, `t2` 为临时寄存器，用于计算。

- **编译与测试**：
  - 使用 `gcc` 编译器编译程序，并确保RISC-V汇编语法正确。

## 注意事项

- 确保替换的汇编指令逻辑正确，能够正确计算斐波那契数列的值。
- 注意内联汇编的语法和寄存器使用。
- 确保程序能够正确处理命令行参数。
- 参与者需要根据题目要求，使用RISC-V汇编语言完成斐波那契数列的计算。通过这个练习，可以加深对RISC-V汇编语言和内联汇编使用的理解。
